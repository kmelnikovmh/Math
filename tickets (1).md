# Билеты к экзамену по алгоритмам.
## Рекурсивный перебор
### <span style="color:green">(a)</span> 1. Перебор всех перестановок за $\mathcal{O}(n!\cdot n)$
* `std::next_premutation`:
```cpp
sort(a.begin(), a.end());
do {
    // ...
} while(next_permutation(a.begin(), a.end()));
```
* Не меняя порядок элементов `a`:
```cpp
vector<int> p = {0, 1, ..., n - 1};
do {
    // use a[p[0]], a[p[1]]...
} while(next_permutation(p.begin(), p.end()))
```
* $\mathcal{O}(n!\cdot n)$, т.к. каждый раз насчитываем целевую функцию

### <span style="color:blue">(b)</span> 2. Перебор перестановок таких, что $|p_{i+1}-p_i| \geqslant 2$

```cpp
void go(int i) {
    if (i == n)
        // получили искомую перестановку
        return;
    for (int x = 0; x < n; ++x) {
        if (!used[x]) {
            if (abs(i - x) > 2) continue; // отсекаем лишние
            used[x] = 1;
            go(i + 1);
            used[x] = 0;
        }
    }
}
```

### <span style="color:blue">(b)</span> `C++: next_permutation`. Сравнение с рекурсией.

* Асимптотика самого перебора одинаковая, т.к. `next_permutation` для перебора всех перестановок работает за [амортизированное $\mathcal{O}(n!)$](https://en.cppreference.com/w/cpp/algorithm/next_permutation "см. Notes")
* Рекурсия более гибкая:
    * Можем по ходу дела насчитывать нужную целевую функцию
    * Можем отсекать ненужные перестановки и работать за $\mathcal{O}(ответа)$.

### <span style="color:red">(c)</span> 4. Перебор всех перестановок за $\mathcal{O}(n!)$.

* Используя `next_permutation`:
```cpp
vector<int> p = {0, 1, ..., n - 1};
do {
    // use a[p[0]], a[p[1]]...
} while(next_permutation(p.begin(), p.end()))
```
* Используя рекурсию:
```cpp
void go(int i) {
    if (i == n)
        // получили искомую перестановку
        return;
    for (int x = 0; x < n; ++x) {
        if (!used[x]) {
            used[x] = 1;
            go(i + 1);
            used[x] = 0;
        }
    }
}
```
### <span style="color:green">(a)</span> 5. Перебор. Рюкзак без стоимостей, subsetsum, $\mathcal{O}(2^n)$.

```cpp
void go(int i, int sum) {
    if (sum >= S) // оптимизация
    if (i == n) {
        if (sum == S); // искомое множество
        return;
    }
    go(i + 1, sum); // used[i] = 0, если необходимо сохранять
    go(i + 1, sum + w[i]); // used[i] = 1
}
```

### <span style="color:blue">(b)</span> 6. Перебор. Рюкзак со стоимостями, knapsack (ограбление банка), $\mathcal{O}(2^n)$.

```cpp
void go(int i, int sw, int scost) {
    if (sw > S) continue; // оптимизация
    if (i == n) {
        ans = max(ans, scost);
        return;
    }
    go(i + 1, sw, scost); // used[i] = 0
    go(i + 1, sw + w[i], scost + cost[i]); // used[i] = 1
}
```

### <span style="color:green">(a)</span> 7. Перебор. Subsetsum. Запоминание $\mathcal{O}(n \cdot S)$.

```cpp
set<pair<int, int>> mem;
void go(int i, int sum) {
    if (sum >= S) // оптимизация
    if (i == n) {
        if (sum == S); // искомое множество
        return;
    }
    if (mem.count({i, sum})) return; // если были - снова не идём
    mem.insert({i, sum}); // запомнили, что были
    go(i + 1, sum);
    go(i + 1, sum + w[i]);
}
```

* Зайдём в каждую комбинацию `<i, S>` не более одного раза, поэтому общее количество вызовов $\mathcal{O}(nS)$, что при небольшом `S` лучше, чем $2^n$

### <span style="color:red">(c)</span> 8. Перебор. Knapsack. Запоминание $\mathcal{O}(n \cdot S)$.
* Пусть перебор возвращает то, сколько ещё можно набрать из оставшихся после `i`-го предметов, если в рюкзаке свободно `W` веса. Тогда можем прикрутить запоминание:
```cpp
map<pair<int, int>> mem;
void go(int i, int W, int sum) {
    if (i == n || W <= 0) return 0;
    if (mem.count({i, W})) return mem[{i, W}]; 
    return mem[{i, W}] = max(go(i + 1, W, sum), // не взяли 
            go(i + 1, W - w[i], sum + cost[i])); // взяли
}
```
* Можно переводить пару в `int64_t` и использовать `unordered_map`.
### <span style="color:green">(a)</span> 9. Перебор. Задача о коммивояжере (развозка пиццы). $\mathcal{O}(n!)$.
```cpp
int go(int cnt, int v) { // развезено cnt
    if (cnt == n) return 0; // развёз всё
    int best = INT_MAX; // лучший вариант
    for (int i = 0; i < n; ++i) {
        if (!used[i]) {
            used[i] = 1;
            best = min(best, dist[v][i] + go(cnt + 1, i)); // dist - двумерный массив расстояний между точками
            used[i] = 0;
        }
    }
    return best;
}
```
### <span style="color:blue">(b)</span> 10. Перебор. Задача о коммивояжере (развозка пиццы). $\mathcal{O}(2^n\cdot n^2)$.
```cpp
map<pair<int, vector<int>>>, int> mem; // [vertex, used] -> оптимальный путь
int go(int cnt, int v) { // развезено cnt
    if (cnt == n) return 0; // развёз всё
    if (mem.count({v, used})) return mem[v, used];
    int best = INT_MAX; // лучший вариант
    for (int i = 0; i < n; ++i) {
        if (!used[i]) {
            used[i] = 1;
            best = min(best, dist[v][i] + go(cnt + 1, i));
            used[i] = 0;
        }
    }
    return mem[v, used] = best;
}
```
* $2^n$ возможных `used` $\times$ $n$ возможных `vertex`, + в каждой такой итерации $n$ шагов цикла $\Longrightarrow$ время работы $\mathcal{O}(2^n \cdot n^2) $.
### <span style="color:green">(a)</span> 11. Перебор. Задача о разбиении на возрастающие слагаемые.

```cpp
int go(int n, int x) { // разбиваемое число и последнее слагаемое
    if (n == 0) return 1;
    int ans = 0;
    for (int y = x + 1; y <= n; ++y)
        ans += go(n - y, y);
    return ans;
}
```

### <span style="color:green">(a)</span> 12. Перебор. Задача о разбиении на возрастающие слагаемые.
```cpp
int go(int n, int x) {
    if (n == 0) return 1;
    return go(n, x - 1) // не взяли x
        + (n < x ? 0 : go(n - x, x));  // взяли
}
```
* Оба работают за $\mathcal{O}(ответа) \approx \mathcal{O}(2^{\sqrt{n}})$
* Добавим мемоизацию. Первое будет работать за $\mathcal{O}(n^3)$ (`n` как число, `n` как слагаемое + `n` итераций цикла по `y`), второе  - за $\mathcal{O}(n^2)$ (`n` как слагаемое и `n` как раскладываемое).
### <span style="color:blue">(b)</span>  13. Перебор. Задача о замощение доминошками $\mathcal{O}(2^{wh/2})$.

```cpp
int go(int x, int y) {
    if (x == w) x = 0, y++; // "возврат каретки"
    if (y == h) return 1; // окончание
    if (!empty[y][x]) return go(x + 1, y);
    int result = 0;
    if (y + 1 < h && empty[y + 1][x]) { // vertical
        empty[y + 1][x] = empty[y][x] = 0;
        result += go(x + 1, y);
        empty[y + 1][x] = empty[y][x] = 1;
    }
    if (x + w < h && empty[y][x + 1]) { // horizontal
        empty[y][x + 1] = empty[y][x] = 0;
        result += go(x + 1, y);
        empty[y][x + 1] = empty[y][x] = 1;
    }
    return result;
}
```

* $\mathcal{O}(2^{\text{число доминошек}}) $.

### <span style="color:red">(c)</span> 14. Перебор. Задача о замощение доминошками $\mathcal{O}(2^w \cdot w \cdot h)$.

```cpp
map<vector<vector<int>>, int> mem; // [empty] -> ответ
int go(int x, int y) {
    if (x == w) x = 0, y++; // "возврат каретки"
    if (y == h) return 1; // окончание
    if (!empty[y][x]) return go(x + 1, y);
    if (m.count(empty)) return m[empty];
    int result = &m[empty];
    if (y + 1 < h && empty[y + 1][x]) { // vertical
        empty[y + 1][x] = empty[y][x] = 0;
        result += go(x + 1, y);
        empty[y + 1][x] = empty[y][x] = 1;
    }
    if (x + w < h && empty[y][x + 1]) { // horizontal
        empty[y][x + 1] = empty[y][x] = 0;
        result += go(x + 1, y);
        empty[y][x + 1] = empty[y][x] = 1;
    }
    return result;
}
```

* Почему $\mathcal{O}(2^w \cdot w \cdot h)$? Потому что все выше левее покрыты, а ниже правее в "суперпозиции" находятся только клетки следующей "изломанной" строки, их ровно $2^w$ + считаем, что в каждое $x, y$ хотя бы по разу динамика зайдёт.

## Динамика база

### <span style="color:green">(a)</span> 15. DP. На примере задачи «калькулятор»: вперёд, назад, relax.

* **Задача**: Дали число 1, можно увеличить на 1, на 7, вдвое, втрое. Нужно дойти до `n` минимальным/максимальным числом шагов/посчитать количество путей.
* **Решение**:
    * Динамика назад: знаем всё что было раньше и формируем актуальный **Ответ:**
    ```cpp
    int f[N]{};
    for (int i = 2; i <= n; ++i) {
        int r = f[i - 1];
        if (i - 7 >= 1) relax(r, f[i - 7]);
        if (i % 2 == 0) relax(r, f[i / 2]);
        if (i % 3 == 0) relax(r, f[i / 3]);
        f[i] = r + 1;
    }
    ```
    * Динамика вперёд: знаем, что сейчас у нас правильный ответ, формируем его в следующих ячейках:
    ```cpp
    int f[N]{};
    for (int i = 1; i < N; ++i) {
        int r = f[i] + 1;
        relax(f[i + 1], r);
        relax(f[i + 7], r);
        relax(f[i * 2], r);
        relax(f[i * 3], r);
    }
    ```

    * `void relax(int&, int)` - функция, улучшающая ответ. Для минимального пути это `min`, для максимального `max`, для количества `+`.

### <span style="color:green">(a)</span> 16. DP. На примере задачи «калькулятор»: ленивая динамика, плюсы и минусы, map.
* Ленивая динамика: перебираем только достижимые состояния.
```cpp
vector<int> f(n + 1, -1);
void calc(int x) {
    int r = &f[x];
    if (r != -1) return r; // уже посчитали
    if (x == 1) return r = 0; // база динамики
    r = calc(x - 1);
    if (r - 7 >= 1) relax(r, calc(x - 7));
    if (r % 2 == 0) relax(r, calc(x / 2));
    if (r % 3 == 0) relax(r, calc(x / 3));
    return ++r;
}
```
* **Минусы**:
    * В данном конкретном случае переберёт те же состояния, что и обычная динамика назад, но рекурсия хуже цикла по константе.
* **Плюсы**:
    * Если переходы были бы наподобие `2x + 1`, `2x + 7`, `3x + 2`, `3x + 10` - ленивая динамика не зашла бы в `[n/2, n)`, и вообще работала бы за логарифм.

### <span style="color:green">(a)</span> 17. DP. Восстановление ответа. Ссылки назад. На примере задачи «путь на матрице».

```cpp
void relax(int x, int y, int F, bool P) {
    if (f[x][y] ... F) 
        f[x][y] = F, p[x][y] = P;
}

int cnt = { 0 }, f = { -inf };
for (int x = 0; x < width; ++x)
    for (int y = 0; y < height; ++y) {
        if (hole[x][y]) continue;
        cnt[x + 1][y] += cnt[x][y];
        cnt[x][y + 1] += cnt[x][y];
        f[x][y] += v[x][y];
        relax(x + 1, y, f[x][y], 0);
        relax(x, y + 1, f[x][y], 1);
    }

void path() {
    for (int x = width-1, y = height-1; x != 0 || y != 0; p[x][y] ? y-- : x--)
        print(x, y);
}
```

* Каждый раз запоминаем откуда пришли, а в конце восстанавливаем ответ идя обратно по этим ссылкам.

### <span style="color:blue">(b)</span> 18. DP. Восстановление ответа без ссылок назад. На примере задачи «путь на матрице».

```cpp
void path() {
    for (int x = width-1, y = height-1; x != 0 || y != 0;) {
        print(x, y);
        if (x > 0 && f[x][y] == f[x - 1][y] + v[x][y]) x--;
        else y--;
    }
}
```
* Смотрим на предшествующую позицию и думаем, а оттуда ли мы пришли? Если нет, значит из другой позиции.

### <span style="color:green">(a)</span> 19. DP. Граф состояний. Вперёд, назад, ленивая на языке графа состояний.
* Состояния динамики - вершины графа, ор.рёбра - переходы, нужно найти путь из начального состояния в конечное/путь минмакс веса/кол-во путей.

* Вперёд - перебираем рёбра, исходящие из `v`, назад - рёбра, входящие в `v`.

* Ленивая динамика - для каждого `v` вычисляем только значения вершин начал входящих в `v` рёбер.

* Rem: граф состояний динамики ацикличен, иначе значение состояния попадает в зависимость от самого себя.

### <span style="color:green">(a)</span> 20. DP. На примере «калькулятор»: checklist (6 пунктов), что должно быть в решении динамикой.
* Checklist:
    1. Состояние динамики - стоим в числе x.
    2. Переходы динамики - перейти в число `x + 1`, `x + 7`, `x * 2`, `x * 3`.
    3. База: `f(1) = 0;`
    4. Ответ: лежит в `f(n)`
    5. Порядок перебора состояний: вперёд/назад/лениво
    6. Восстановление ответа: нет/обратные ссылки/как-то по другому

### <span style="color:green">(a)</span> 21. DP. Рюкзак без стоимостей.

```cpp
bool is[n + 1][2S + 1]{}; // функция - "можем ли получить такой вес", состояние - "посмотрели на первые n предметов и набрали вес S"
is[0][0] = 1; // База - ничего не взяли.
for (int = 0; i < n; ++i)
    for (int j = 0; j <= S; ++j)
        if (is[i][j])
            is[i + 1][j] = is[i + 1][j + a[i]] = 1; // Переход: взяли/не взяли i-й предмет
```
* Время и память $\Theta(nS)$.

### <span style="color:blue">(b)</span> 22. DP. Рюкзак со стоимостями.

```cpp
int is[n + 1][2S + 1]{}; // функция - "макс.сумма для этого веса и набора предметов", состояние - "посмотрели на первые n предметов и набрали вес S"
is[0][0] = 0; // База - ничего не взяли.
for (int = 0; i < n; ++i)
    for (int j = 0; j <= S; ++j)
        is[i][j] = max(is[i - 1][j], is[i - 1][j - w[i]] + c[i]); // Переход: что выгоднее всего доложить в рюкзак?
```

### <span style="color:blue">(b)</span> 23. DP. Рюкзак + bitset.
* Во-первых, для линейной памяти можно хранить 1 строку динамики, во-вторых, используем `bitset`:
```cpp
bitset<S+1> is;
is[0] = 1;
for (int = 0; i < n; ++i)
    for (int j = S - a[i]; j >= 0; --j) // с конца, чтоб не сломать инвариант
        is |= is << w[i]; // O(S/w)
```
* Время и память $\Theta(\frac{nS}{w})$, где $w = 64$ - размер машинного слова. 

### <span style="color:red">(c)</span> 24. DP. Рюкзак. Восстановление ответа с линейной памятью.

```cpp
int last[S = 1] { - 1 };
last[0] = 0;
for (int i = 0; i < n; ++i)
    for (int j = S - a[i]; j >= 0; j--)
        if (last[j] != -1 && last[j + a[i]] == -1)
            last[j + a[i]] = i;

void ans() {
    for (int w = S; w > 0; w -= a[last[w]])
        print(last[w]);
}
```
* Каждый раз запоминаем откуда пришли и по обратным ссылкам восстанавливаем ответ.

### <span style="color:green">(a)</span> 25. DP. Квадратные: НВП.

* **Состояние:** стоим в `i`-м элементе.
* **Функция:** НВП, заканчивающаяся в `i`.
* **Переходы:** $f[i] = 1 + max(f[j])$ по $j < i$ и $a_j < a_i$.
* **Ответ:** $max(f)$.
* **Время:** $\Theta(n^2)$, память $\Theta(n)$

### <span style="color:green">(a)</span> 26. DP. Квадратные: НОП.

* **Состояние:** стоим в `i`-м элементе `a` и `j`-м `b`.
* **Функция:** НОП для префиксов `a[1...i]` и `b[1...j]`.
* **Переходы:** $f[i] = max(f[i - 1][j], f[i][ j - 1], (f[i - 1][j - 1] + 1) \cdot (a[i] == b[j]))$.
* **Ответ:** $max(f)$.
* **Время:** $\Theta(n^2)$, память $\Theta(n^2)$

### <span style="color:blue">(b)</span> 27. DP. Квадратные: Левенштейн.

* **Состояние:** стоим в `i`-м элементе `s` и `j`-м `t`.
* **Функция:** НОП для префиксов `a[1...i]` и `b[1...j]`.
* **Переходы:** $f[i] = max(f[i - 1][j] + 1, f[i][j - 1] + 1, f[i - 1][j - 1] + !(s[i] == t[j]))$.
* **Ответ:** $f[n][m]$.
* **Время:** $\Theta(n^2)$, память $\Theta(n^2)$

### <span style="color:green">(a)</span> 28. DP. НОВП. $\mathcal{O}(n^4)$.

* **Состояние:** `i`-й в `a` и `j`-й в `b`.
* **Функция:** длина НОВП, кончается в `a[i] = b[j]`.
* **Переходы:** выбрали $i_1 > i$ и $j_1 > j$ т.ч. $a[i_1] > a[i] \&\& a[i_1] == b[j_1]$.
* **Ответ:** $f[n][m]$
* **Время:** квадрат на квадрат = $\mathcal{O}(n^4)$.

### <span style="color:blue">(b)</span> 29. DP. НОВП. $\mathcal{O}(n^3)$

* **Состояние:** `i`-й в `a` и `j`-й в `b`.
* **Функция:** длина НОВП, кончается в `a[i]` и где-то в `b[1...j]`.
* **Переходы:** если `a[i] != b[j]`, то `d[i][j] = d[i][j - 1]`, иначе пробежим циклом по `a` и для `a[k] < a[i]` возьмём тот, для которого `d[k][j] + 1` максимально.
* **Ответ:** $max_{i}(f[i][m])$
* **Время:** квадрат на линию = $\mathcal{O}(n^3)$.

### <span style="color:red">(c)</span> 30. DP. НОВП. $\mathcal{O}(n^2)$

* То же, что выше, но не будем бежать циклом, а будем хранить элемент `best` такой, что `b[best] < a[i]` и `d[i - 1][best]` максимально.

### <span style="color:green">(a)</span> 31. DP. Разбинение строки на палиндромы.

* **Состояние:** стоим в `i`-м элементе
* **Функция:** кол-во палиндромов, на которые можно разбить префикс
* **Переход:** $f[i] = min(f[j] + 1)$ т.ч. `j < i` и `[j, i)` - палиндром. 
* Проверку палиндрома можем предпосчитать за квадрат памяти, можем для каждого `i` найти $r_0[i]$ и $r_1[i]$ - длины макс.палиндромов чётной/нечётной длины с центром в `i`.

### <span style="color:blue">(b)</span> 32. DP. Хиршберг. Применение для НОП. Без времени работы.

* Обозначим `n' = n/2`. Теперь найдём префиксный НОП `f` на `a[1...n']` и `b[0...j]` и суффиксный `g` на `a[n'...n]` и `b[0...j]`. Теперь возьмём `j` такое, что `f[n'][j] + g[n - n'][m - j] = max` и сделаем 2 рекурсивных вызова от половинок `a[1...n'] b[1...j]` и `a[n'...n] b[j...m]`.

### <span style="color:red">(c)</span> 33. DP. Хиршберг. Применение для НОП, Левенштейна. Время работы.

* Время работы: глубина рекурсии - `log2(n)`, на каждом уровне `m` - размер подзадачи. Тогда общее время `T = nm + n/2 m + n/4 m + ... <= 4nm`. Получается $\mathcal{O}(nm) $ времени.
 
### <span style="color:red">(c)</span> 34. DP. Улучшенный Хиршберг, применение для рюкзака с весами.

### <span style="color:blue">(b)</span> 35. DP. bitset. Что умеет? За сколько? Как устроен? Перебор единичных бит.

* `bitset` - массив бит. Можно обращаться по индексу за $\mathcal{O}(1)$, а ещё производить битовые операции: `&`, `||`, `<<`, `^`.
* Устроен как массив из $\frac{n}{w}$ целых чисел, где $w = 64$ - размер машинного слова.
* то есть, может за 1 такт производить битовую операцию над $w$ битами, и все асимптотики улучшаются в 64 раза относительно массива чисел.
* Можем делать всякие классные штучки с битами, в частности, получить младший бит - $x' = x \& ~(x - 1)$. Потом делая $x$ XOR $x'$ убираем этот бит и ищем следующий. Получаем по сути бесплатный перебор единичных бит.

## Динамика задачи, идеи

### <span style="color:blue">(b)</span> 36. DP. Игра в камни. Несимметричная win[n,whoMoves].

* **Состояние:** `i` - в куче осталось камней, `p` - кто ходит.
* **Функция:** есть ли у `p` гарантированный способ выиграть?
* **Переходы:** $f[i][1] = !f[i - a_1][2] || !f[i - a_2][2]$ и наоборот.

### <span style="color:blue">(b)</span> 37. DP. Игра в камни. Симметричная win[n].

* **Состояние:** `i` - в куче осталось камней.
* **Функция:** есть ли у ходящего гарантированный способ выиграть?
* **Переходы:** $f[i] = !f[i - a_1] || !f[i - a_2]$ и наоборот.

### <span style="color:green">(a)</span> 38. DP. По дереву. Размер поддеревьев.
* **Состояние:** `v` - вершина в которой находимся.
* **Функция:** размер всех поддеревьев.
* **Переход:** $f[v] = 1 + \sum_x size[x]$, где $x$ - дети $v$.

### <span style="color:blue">(b)</span> 39. DP. По дереву. Паросочетание минимального веса.

* **Состояние:** `v` - вершина в которой находимся
* **Функция:** $f_0$ - вес максимального парсоча поддерева $v$ без $v$;
               $f_1$ - вес максимального парсоча поддерева $v$ с $v$;
               $f = max(f_0, f_1)$.
* **Переход:** $f_0[v] = \sum_i f[x_i]$, $f_1[v] = \sum_i + \max_i(w_i - f[x_i]+f_0[x_i])$ - где $x_i$ - дети $v$, у всех взяли из $f$, а у той, с кем соединили, из $f_0$.

### <span style="color:red">(c)</span> 40. DP. По дереву. Связное поддерево размера k минимального веса.

* **Состояние:** `i` - размер обрубка поддерева, `v` - вершина в которой находимся.
* **Функция:** минимальный вес обрубка поддерева.
* **Переход:** запустим рюкзак по детям; по итогу $f[v][i] = g[v][\deg v_i][i]$; $g[v, j+1, i] = \min_x(g[v][j][i - x] + f[\text{j-й ребенок}][x])$.
* Пишем динамику вперёд и получаем $\mathcal{O}(nk)$.

### <span style="color:blue">(b)</span> 41. DP. Разбиения числа n на неупорядоченные слагаемые.

* Если я не туплю, то это просто $f[1] = 1$, а для любого другого сумма по всем предыдущим + 1, ну потому что взяли любое из предыдущих и подставили разницу...

### <span style="color:blue">(b)</span> 42. DP. Разбиения числа n на ровно k неупорядоченных слагаемых

* **Состояние:** `n` - разбиваемое, `k` - количество слагаемых.
* **Функция:** количество разбиений на не более, чем $k$ слагаемых.
* **Переход:** $f[n][k] = f[n][k - 1] + f[n - k][k]$ - либо слагаемых меньше, чем $k$, либо из каждого вычитаем 1.
* **Ответ:** Из каждого в искомом разбиении отнимем 1 и уберем ноль. Получим, что ответ равен $p[n - k][k]$.

### <span style="color:red">(c)</span> 43. DP. Разбиения числа n на слагаемые: $\mathcal{O}(n)$ памяти, как хранить ровно одну строку?

* Точно так же, как раньше, но теперь используем $f[k][n]$. Заметим, что мы везде обращаемся к $k$ и $k - 1$, значит это сработает.

### <span style="color:blue">(b)</span> 44. DP. Проверка «подходит ли под шаблон». Линия памяти.

* **Состояние:** `i`-й элемент строки, `j`-й элемент шаблона.
* **Функция:** подходит ли префикс строки под префикс шаблона.
* **Переход:** Если $p[j - 1]$ - буква, то $f[i][j] = f[i - 1][j - 1] \&\& p[j - 1] == s[i - 1]$. Если $p[j - 1] == '?'$, то $f[i][j] = f[i - 1][j - 1]$, если $p[j - 1] == '*'$, то $f[i][j] = f[i][j - 1] || f[i][j - 1]$ - либо звёздочка это пустая строчка, либо что-то взяла.

### <span style="color:blue">(b)</span> 45. DP. НВП за $\mathcal{O}(n \log n)$ (только длина).

* **Состояние:** `i` - элемент п-ти.
* **Функция:** Число, на которое кончается последовательность.
* **Переход:** $j = lower\_bound(x, x+n,a[i]) - x$, $x[j] = a[i]$ - для каждого элемента ищем наираньшее место, куда его можно поставить. Ответ - $max(j)$ по итерациям.

### <span style="color:red">(c)</span> 46. DP. НВП за $\mathcal{O}(n \log n)$ (восстановление ответа).

* Обратные ссылки: $xp[j] = i$, $prev[i] = xp[j - 1]$.
* Непосредственно восстановление:
```cpp
    int p = xp[ans];
    while (p != -1) {
        anss.push_back(p);
        p = prev[p];
    }
```

### <span style="color:green">(a)</span> 47. DP. По подотрезкам. Задача «погрузка на корабль». Решение за $\mathcal{O}(n^4)$.

* **Состояние:** остался массив $[L, R]$.
* **Функция:** кол-во отплывших кораблей.
* **Переходы:** $k[L'][R'] = k[L][R] + 1$, где $sum[L, L') + sum(R', R] \leqslant S$.
* **Время:** Квадрат состояний + перебор новых границ = $\mathcal{O}(n^4)$.

### <span style="color:blue">(b)</span> 48. DP. Измельчение перехода на примере задачи «погрузка на корабль». $\mathcal{O}(n^3)$.

* **Состояние:** остался массив $[L, R]$, уплыло $k$ кораблей.
* **Функция:**: вес загружаемого корабля.
* **Переходы:**: $w[k, L + 1, R] = w[k, L, R] + weight[L]$, $w[k, L, R - 1] = w[k, L, R] + weight[R]$ если вмещаются, в любом случае: $w[k + 1][L][R] = 0$.
* **Время:** Куб состояний, никаких переборов = $\mathcal{O}(n^3)$.

### <span style="color:red">(c)</span> 49. DP. Использование пары в функции на примере задачи «погрузка на корабль». $\mathcal{O}(n^2)$.

* **Состояние:** остался массив $[L, R]$.
* **Функция:** пара $<k, w>$, где $k$ кораблей уплыло, $w$ загружено в нынешний корабль. Минимизируем в первую очередь $k$, во вторую - $w$.
* **Переходы:** Если вмещается: $<k, w + weight[L]>[L + 1][R] = relax(<k, w>[L, R])$, иначе $<k + 1, weight[L]>[L + 1][R] = relax(<k, w>[L, R])$, для правого контейнера аналогично.
* **Время:** Квадрат.

### <span style="color:green">(a)</span> 50. DP. Рекуррентные соотношения за $\mathcal{O}(k^3 \log n)$.

* Рекуррентное соотношение можно задать как матрица умноженная на первые $k$ членов. Матрица задаётся так что в первой строчке коэффициенты соотношения, ниже на диагонали единички. 
* Возводить в степень умеем за $\log n$, общее время будет $k^3 \log n$, т.к. $k^3$ - время одного умножения двух матриц.

### <span style="color:blue">(b)</span> 51. DP. Пути в графе за $\mathcal{O}(kn^2)$ и $\mathcal{O}(n^3 \log k)$.

* **Состояние:** прошли `k`.
* **Функция:** количество путей.
* **Переход:** $f[k][v] = \sum_i f[k - 1][i] \cdot C[i][v] = C \cdot f[k - 1] = C^kf_0$.
* **Время:** в лоб - $\mathcal{O}(kn^2)$, если использовать трюк с возведением матрицы в степень - то $\mathcal{O}(n^3\log k)$.

### <span style="color:green">(a)</span> 52. DP. Задача «почтовые отделения». Решение за $\mathcal{O}(n^4 + n^2k)$.

* Пусть `x` и `i` отсортированы. Тогда города бьются на $k$ отрезков с границами в $\frac{1}{2}(x_{i_t} + x_{i_{t + 1}})$, нужно минимизировать $\sum_{i=1..k}cost(p_i, p_{i+1}-1)$, где $p$ - границы отрезков.
* Подобрали, решаем динамикой: 
* **Состояние:** `n` городов, `k` отрезков.
* **Функция:** стоимость разбиения.
* **Переход**: $f[k][n] = f[k - 1][p[k][n]] + cost[p[k][n] + 1][n]$
* **Время**: $\mathcal{O}(kn^2) + n^2 \cdot ccost$, где $ccost$ - время подсчёта $cost$. Если квадрат, в итоге получаем $\mathcal{O}(n^4 + n^2k)$.

### <span style="color:blue">(b)</span> 53. DP. Задача «почтовые отделения». Использование частичных сумм для вычисления функции на отрезке за $\mathcal{O}(1)$ с предподсётом $\mathcal{O}(n)$. Решение за $\mathcal{O}(n^2k)$.

* Зная $m[l][r]$ (середину отрезка) можем посчитать $cost(l, r)$ за $\mathcal{O}(1)$. 
* $\sum_{i=l..r}w_i|x_i-x_m| = \sum_{i=l..m}w_i|x_i-x_m| + \sum_{i=m..r}w_i|x_i-x_m| = x_m(\sum_{i=l..m}w_i - \sum_{i=m..r}w_i) - \sum_{i=l..m}x_iw_i + \sum_{i=m..r}x_iw_i$.
* Это 4 суммы на отрезках, каждая считается через префсуммы.

### <span style="color:blue">(b)</span> 54. DP. Оптимизации. Кнут. $\mathcal{O}(n^2)$.

* Пусть $p[k -1][n] \leqslant p[k][n] \leqslant p[k][n + 1]$. Тогда можем перебирать $p[k][n]$ не от $0$ до $n - 1$, а от $p[k-1][n]$ до $p[k][n + 1]$.
* Доказательства как-нибудь потом...

### <span style="color:red">(c)</span> 55. DP. Оптимизации. Разделяй и властвуй. $\mathcal{O}(nk \log n)$.

* Насчитали строку $f[k - 1]$, найдём $p_k$ и посчитаем $f[k]$ за $\mathcal{O}(n)$.
* Уже знаем, что $\forall n, k \: p_{k, n}\leqslant p_{k, n+1}.$ Тогда код:
```cpp
void go(int l, int r, int L, int R) {
    if (l > r) return;
    int m = (l + r) / 2;
    // ищем p[k, m] в лоб за O(R-L+1)
    go(l, m - 1, L, p[k][m]);
    go(m + 1, r, p[k][m], R);
}
go(1, n, 1, n) // init
```
* Глубина рекурсии $\log n$, на каждом уровне сумма подзадач $n$, время работы $\mathcal{O}(n \log n)$

### <span style="color:green">(a)</span> 56. DP. Стресс-тестирование для проверки гипотез на примере «почтовые отделения».

* Глобально три подхода:
    1. Взять решение без оптимизации и с ней, сравнить ответ на случайных тестах.
    2. На случайных тестах сравнить итоговый массив динамики.
    3. Поставиь внутри решения без оптимизации `assert(инвариант)`.
* (2) всегда лучше, чем (1), т. к. сильнее свидетельствует о корректности.
* С (3) нужно быть осторожным, так как не всегда для каждого корректного решения инвариант выполняется.

### <span style="color:green">(a)</span> 57. DP. По подотрезкам. Оптимальное умножение матриц. $\mathcal{O}(n^3)$.

* **Состояние:** подотрезок $[l, r]$.
* **Функция:** минимальное количество действий, необходимое для перемножения.
* **Переход:** $f[l, r] = \min_{m\in[l, r)}(f[l, m-1] + f[m, r] + a_la_ma_{r+1})$
* **Время:** $\mathcal{O}(n^3)$ т.к. квадрат дают $l,r$ и ещё линию поиск оптимального $m$.

### <span style="color:green">(a)</span> 58. DP. Комбинаторика. Перестановка по номеру.

* Пробуем ставить минимальное `d`. Есть `(n-1)!` способов продолжить. Если $k\leqslant(n-1)!$, ставим `d`, иначе уменьшаем `k` на `(n-1)!` и увеличиваем `d`.

### <span style="color:green">(a)</span> 59. DP. Комбинаторика. Номер по перестановке.

* Считаем, сколько перестановок лексикографически меньше, чем `p`. Идём по `k` и увеличиваем счётчик на `(n-k)!` - способы закончить перестановку.

```cpp
vector<bool> was(n + 1);
int result = 0;
for (int k = 1; k <= n; ++k) {
    was[p[k]] = true;
    for (int j = 1; j < p[k]; ++j)
        if (!was[j])
            result += (n-k)!;
}
```

### <span style="color:blue">(b)</span> 60. DP. Комбинаторика. Скобочная последовательность по номеру.

* Предпосчитаем динамику `dp[i][balance]` - количество способов дополнить до ПСП.

* $dp[k, b] = dp[k + 1, b + 1] + (b == 0 ? 0 : dp[k + 1, b - 1])$. Тогда код:

```cpp
int balance = 0;
for (int i = 0; i < n; ++i) {
    if (k <= dp[i + 1][balance + 1])
        s[i] = '(', balance++;
    else
        k -= dp[i + 1][balance + 1],
        s[i] = ')', balance--;
}
```

### <span style="color:blue">(b)</span> 61. DP. Комбинаторика. Номер по скобочной последовательности.

* Ищем кол-во ПСП, лексикографически меньших s. Воспользуемся динамикой из прошлого билета.

```cpp
int balance = 0, result = 0;
for (int k = 0; k < n; ++k) {
    if (s[k] == ')')
        result += dp[k, balance + 1]; // тип заменили на ( и всё стало меньше.
    balance += (s[k] == '(' ? 1 : -1);
}
```

### <span style="color:red">(c)</span> 62. DP. Комбинаторика. Следующий лексикографически. 2 примера.

### <span style="color:red">(c)</span> 63. DP. Комбинаторика. Количество чисел на отрезке $[L, R]$ кратных $m$ за $\mathcal{O}(m \log R).

## Динамика по подмножествам

### <span style="color:green">(a)</span> 64. DP. Представление множеств масками бит. 10 операций за O(1).

* Существует `Биекция Животворящая` между подмножествами `A` и числами от 0 до $2^n-1$. Т.е. где в числе 1, значит элемент включен в подмножество, 0 - не включён.
* 10 заповедей Копеля:
    1. `(1 << n) - 1` - Всё множество.
    2. `(A >> i) & 1` - проверить, есть ли `i`-й элемент в множестве.
    3. `A | (1 << i)` - добавить `i`-й.
    4. `A & ~(1 << i)` - удалить `i`-й.
    5. `A ^ (1 << i)` - был удалить, не было добавить.
    6. `A & B` - пересечение.
    7. `A | B` - объединение.
    8. `X & ~A` - дополнение.
    9. `A & ~B` - разность.
    10. `(A & B) == A` - является ли `A` подмножеством `B`.

### <span style="color:green">(a)</span> 65. DP. Число бит (элементов) и сумма в множестве.

```cpp
for (int A = 1; A < (1 << n); ++A)
    bit_cnt[A] = bit_cnt[A >> 1] + (A & 1);
```

* Сумма - просто умножаем `A & 1` на `w[i]`:

```cpp
for (int A = 1; A < (1 << n); ++A)
    bit_cnt[A] = bit_cnt[A >> 1] + (A & 1) * w[i];
```

### <span style="color:green">(a)</span> 66. Рекурсия. Число бит (элементов) в множестве рекурсией.

```cpp
void go(int i, int A, int result) {
    if (i == n) {
        bit_cnt[A] = result;
        return;
    }
    go(i + 1, A, result); // типа поставили 0
    go(i + 1, A | (1 << i), result + 1); // типа поставили 1
}
```

### <span style="color:green">(a)</span> 67. DP. Гамильтонов путь за $\mathcal{O}(2^nn^2)$.

```cpp
for (int i = 0; i < n; ++i) 
    is[1 << i][i] = 1; // База - путь из 1 вершины
for (int A = 0; A < (1 << n); ++A) // Рассматриваем путь, содержащий мн-во вершин А
    for (int v = 0; v < n; ++v) if (is[A][v]) // Если путь может кончаться в v
        for (int x = 0; x < n; ++x) if (!(A & (1 << x)) && g[x][v]) // x не лежит в А и из v есть ребро в x
            is[A | (1 << x)][x] = 1; // Значит путь, содержащий А + x может заканчиваться в x.
```

### <span style="color:blue">(b)</span> 68. DP. Гамильтонов путь за $\mathcal{O}(2^nn)$ времени и $\mathcal{O}(2^n)$ памяти.

* Используем битовые операции. Строка динамики - `n` бит, будем хранить как 1 uint. Тогда код:

```cpp
for (int i = 0; i < n; ++i) 
    ends[1 << i] = (1 << i); // База - путь из 1 вершины
for (int A = 0; A < (1 << n); ++A) // Рассматриваем путь, содержащий мн-во вершин А
        for (int x = 0; x < n; ++x) // Перебираем вершину куда пойдём из А
            if (!(A & (1 << x)) && g[x] | ends[A] != 0) // Откуда-то можем прийти в x
                ends[A | (1 << x)] |= 1 << x; // Значит можем прийти в A + x и закончить в х.
```

### <span style="color:blue">(b)</span> 69. DP. Гамильтонов цикл.

```cpp
if (g[0] | ends[(1 << n) - 1] != 0) hasCycle = True; // Если смогли пройти весь путь и вернуться в 0, значит есть цикл.
```

### <span style="color:green">(a)</span> 70. DP. Перебор всех подмножеств. Два доказательства $3^n$.

```cpp
for (B = 0; B < (1 << n); ++B) // Перебираем В
    for (C = B; C > 0; C--, C &= B) // Перебираем С такое, что оно содержится в В
```

* **Время работы:** $O(3^n)$.
* **Доказательство:** Каждый элемент находится в 1 из 3 состояний: не попал в В, попал в В \ C, попал в С. $3^n$ вариантов.
* **Доказательство:** $\sum_A 2^{n-|A|} = \sum_C 2^{|C|} = \sum_k \binom{n}{k} 2^k = (1+2)^n=3^n$.

### <span style="color:blue">(b)</span> 71. DP. Перебор всех надмножеств.

```cpp
for (B = 0; B < (1 << n); ++B) // Перебираем В
    for (C = 0; C < (1 << n); C++, C |= B) // Перебираем С такое, что оно содержит B
```

### <span style="color:green">(a)</span> 72. DP. Вершинная покраска за $\mathcal{O}(4^n)$. Связь с независимыми множествами.

```cpp
for A = 0...2^n-1 // Перебираем все множества А
    for B = 0...2^n-1 // Все множества В
        if A in B and is[B \ A] // Если А содержится в В и разность - независимое
            relax(f[B], f[A] + 1); // То можно разность покрасить в новый цвет + А уже раскрашено
```

### <span style="color:green">(a)</span> 73. DP. Вершинная покраска за $\mathcal{O}(3^n)$.

```cpp
for (A = 0; A < (1 << n); ++A) // Перебираем A
    for (B = 0; B < (1 << n); B++, B |= A) // Перебираем B такое, что оно содержит A
        if is[B \ A] // Если разность - независимое
            relax(f[B], f[A] + 1); // То можно разность покрасить в новый цвет + А уже раскрашено
```

### <span style="color:blue">(b)</span> 74. DP. Вершинная покраска за $\mathcal{O}(2.44^n)$. Общий алгоритм, время работы $\mathcal{O}(2.44^n)$.

* Вместо всех подмножеств `A` будем перебирать только максимальные по включению независимые подмножества.
* **Доказательство времени работы:** $\sum_A 1.44^{n-|A|} = \sum_C 1.44^{|C|} = \sum_k \binom{n}{k} 1.44^k = (1+1.44)^n=2.44^n$.

### <span style="color:red">(c)</span> 75. DP. Способ перебора и обоснование количества максимальных по включению независимых подмножеств. Пример, на котором оценка достигается.

### <span style="color:blue">(b)</span> 76. DP. Предподсчёт независимости всех подмножеств за $\mathcal{O}(2^n)$.

```cpp
void solve(A, g): // A - текущее независимое подмножество
    if (g.empty()): // g - граф
        ind[A] = true,
        return;
    v = // вершина макс.степени в g
    solve(A | (1 << v), g \ {v, g[v]});
    for (u : g[v])
        solve(A | (1 << u), g \ {u, g[u]})
```

### <span style="color:red">(c)</span> 77. DP. Количество независимых подмножеств для каждого множества за $\mathcal{O}(2^n)$.

### <span style="color:blue">(b)</span> 78. DP. Развёрнутая битовая запись.

* Задинамим предподсчётик: когда имеем `x`, у нас уже есть ревёрснутые старшие биты кроме одного:
```cpp
reverse[0] = 0;
for (int x = 1; x < (1 << n); ++x)
    reverse[x] = (reverse[x >> 1] >> 1) + ((x & 1) << (n - 1)) // взяли 7 старших битов и ревёрснули, поставили на место, потом взяли младший, и поставили в начало.
```

### <span style="color:green">(a)</span> 79. DP. Биты. Степень двойки? Номер старшего бита?

* `(x & (x - 1)) == 0` - выкинули младшую единичку.
* Бинпоиск, ищем такое `L` что $2^L \leqslant x < 2^{L+1}$. L - ответ.

### <span style="color:blue">(b)</span> 80. DP. Биты. Номер младшего бита за $\mathcal{O}(1)$.

* Предподсчитаем $f[2^i] = i$ (для экономии памяти храним в $2^i \mod m$, для `w = 64` пойдёт `m = 67`), берём `a = x & ~(x - 1)`, f[a] - ответ.

### <span style="color:red">(c)</span> 81. DP. Биты. Чётность количества бит. Количество бит.

### <span style="color:blue">(b)</span> 82. DP. SetCover. $\mathcal{O}^*(2^{min(n,m)})$.

* **Состояние:** `B` - подмножество
* **Функция:** - минимальное число множеств из $A_i$, дающих в объединении `B`.
* **База:** `f[0] = 0`.
* **Переход:** $relax(f[B\cup A_i], f[B] + 1)$ - тип присоединили ещё множество и сказали: "ну, получается можем, но ещё одно взяли, так что ответ увеличиваем на 1".
* **Ресурсы:** Память $\mathcal{O}(2^n)$, время $\mathcal{O}(2^nm)$, $m$ - кол-во переходов из каждого состояния.

### <span style="color:blue">(b)</span> 83. DP. Перевозка грузов за $\mathcal{O}^*(3^n)$.

* Для каждого подмножества `T` посчитаем, можно ли его увезти за 1 раз, для этого запускаем что-то типа рюкзака: "$f[T][i]$ - можно ли увезти $T$ первыми $i$ машинами".
* `f[T][i] |= f[T \ T_1][i - 1] && sum[T_1] <= W[i]`, если `f[T][k] = true`, то можно.
* Минимизируем ответ как-то типа `relax(d[S], d[S \ T] + 1)`, где `T` можем увезти за 1 раз.

### <span style="color:red">(c)</span> 84. DP. Перевозка грузов за $\mathcal{O}(2^nn)$.

### <span style="color:red">(c)</span> 85. DP. Количество паросочетаний за $\mathcal{O}(2^nn)$.

### <span style="color:red">(c)</span> 86. DP. Йатс. $\forall A$ сумма по всем подмножествам A за $\mathcal{O}(2^nn)$.

### <span style="color:green">(a)</span> 87. DP. Lazy. Количество клик рекурсивным перебором за $\mathcal{O}(2^{n/2})$.

* Для начала напишем за $\mathcal{O}(2^n)$:

```cpp
int solve(int i, int A) {
    if (A == 0) return 1;
    return solve(i + 1, A & ~(1 << i)) ((A & (1 << i)) ? solve(i + 1, A & g[i]) : 0)
}
```

* `A` - множество, которое можем добавить, `g[i]` - соседи.
* Можем сделать ленивку, добавив запоминание `A` (вместо `i` будем брать младший бит `A`).

### <span style="color:blue">(b)</span> 88. DP. Lazy. Количество клик рекурсивным перебором: обоснование времени работы $\mathcal{O}(2^{n/2})$.

* Пар с $i \leqslant n/2$ немного, а те где $i>$, мы часто упираемся в запомненные значения (у `A` первые `i` бит нулевые, дальше $2^{n - i}$ вариантов).
* Тогда асимптотика $\mathcal{O(2^{n/2})}$.

### <span style="color:green">(a)</span> 89. DP. Lazy. Перебор для замощения доминошками за $\mathcal{O}(2^{wh/2})$.

```cpp
int go(int x, int y) {
    if (x == w) x = 0, y++; // "возврат каретки"
    if (y == h) return 1; // окончание
    if (!empty[y][x]) return go(x + 1, y);
    int result = 0;
    if (y + 1 < h && empty[y + 1][x]) { // vertical
        empty[y + 1][x] = empty[y][x] = 0;
        result += go(x + 1, y);
        empty[y + 1][x] = empty[y][x] = 1;
    }
    if (x + w < h && empty[y][x + 1]) { // horizontal
        empty[y][x + 1] = empty[y][x] = 0;
        result += go(x + 1, y);
        empty[y][x + 1] = empty[y][x] = 1;
    }
    return result;
}
```

### <span style="color:blue">(b)</span> 90. DP. Lazy. Динамика для замощения доминошками, оценка $\mathcal{O}(hw2^{min(h,w)})$ числа состояний.

* Почему $\mathcal{O}(2^w \cdot w \cdot h)$? Потому что все выше левее покрыты, а ниже правее в "суперпозиции" находятся только клетки следующей "изломанной" строки, их ровно $2^w$ + считаем, что в каждое $x, y$ хотя бы по разу динамика зайдёт.

### <span style="color:red">(c)</span> 91. DP. Lazy. Оптимизация константы рекурсивной версии. Нерекурсивная версия.

### <span style="color:green">(a)</span> 92. Meet-In-The-Middle. Для игры «из исходной перестановки за 40 ходов получи нужную».

* Классический `meet-in-the-middle` - сделали по $2^20$ перестановок от A и от B, а потом смотрим на пересечение получившихся множеств: не пусто ли.

### <span style="color:green">(a)</span> 93. Meet-In-The-Middle. Для рюкзака без стоимостей.

* Разбили `A` на 2 половины по `n/2` чисел, в каждой половине посчитаем суммы и сложим в массивы `B` и `C`. Проверим для элементов этих массивов за `nm` нет ли двух элементов, которые дают в сумме `S` (ладно, можно за логарифм, но тут в целом не критично).

### <span style="color:blue">(b)</span>  94. Meet-In-The-Middle. Для рюкзака со стоимостями.

* Разбили на 2 половины. Для каждого подмножества половин посчитали вес и стоимость, теперь `B` и `C` - массивы пар. Один отсортировали, а для другого ищем бинпоиском такую пару, чтоб влезало в рюкзак. Максимизируем стоимость того, что уносим.
* Можно посортить оба и идти двумя указателями.

### <span style="color:red">(c)</span>  95. Meet-In-The-Middle. Для количества клик за $\mathcal{O}(2^{n/2}n^2)$.

### <span style="color:red">(c)</span> 96. Meet-In-The-Middle. Для количества клик за ровно $\mathcal{O}(2^{n/2})$.

### <span style="color:red">(c)</span> 97. DP. Покрытие доминошками, версия без рекурсии.

### <span style="color:red">(c)</span> 98. ФВИ. Покраска вершин графа за $\mathcal{O}(2^{n}n)$.

### <span style="color:red">(c)</span> 99. Перебор. Максимальная клика за $\mathcal{O}(1.38^n)$.

## DFS

### <span style="color:green">(a)</span> 100. Хранение графа. Списки vector<vector>. Матрица vector<bitset>.

* `vector<vector<bool>>` подойдёт для простого невзвешенного графа
* `vector<vector<int>>` - для простого взвешнного графа или невзвешенного мультиграфа
* `vector<int> c[n][n]` - список всех весов всех рёбер между парами для взвешенного мульиграфа.

* `vector<vector<bool>>` - по факту битсеты (под капотом вектора).

### <span style="color:blue">(b)</span> 101. Хранение графа. vector<set>, сравнение трёх способов.

* Можно хранить `vector<set>` - для каждой вершины в сете инцидентные ей рёбра/вершины.
* Рассмотрим операции:
    * `adjacent(v)` - перебор инцидентных `v` рёбер.
    * `get(a, b)` - смежны ли `a`, `b`?
    * `all` - все рёбра
    * `add(a, b)` - связать вершины ребром
    * `del(a, b)` - разорвать ребро

|          | `adjacent` | `get` | `all` | `add` | `del` | `memory` |
|----------|------------|----------|----|----|----|----|
| Список рёбер | $\mathcal{O}(E)$ | $\mathcal{O}(E)$   |  $\mathcal{O}(E)$ | $\mathcal{O}(1)$  | $\mathcal{O}(E)$  | $\mathcal{O}(E)$  |
| Матрица смежности    | $\mathcal{O}(V)$     | $\mathcal{O}(1)$   | $\mathcal{O}(V^2)$  |  $\mathcal{O}(1)$ | $\mathcal{O}(1)$  |  $\mathcal{O}(V^2)$ |
| vector смежности    | $\mathcal{O}(\deg)$     | $\mathcal{O}(\deg)$  | $\mathcal{O}(V+E)$ |  $\mathcal{O}(1)$ | $\mathcal{O}(deg)$  | $\mathcal{O}(E)$ |
| hashTable смежности    | $\mathcal{O}(1)$     | $\mathcal{O}(\deg)$  | $\mathcal{O}(V+E)$ |  $\mathcal{O}(1)$ | $\mathcal{O}(1)$  | $\mathcal{O}(E)$ |

### <span style="color:red">(c)</span> 102. Хранение графа. Мультисписок. Сравнение с vector<vector> (время, память).

### <span style="color:green">(a)</span> 103. DFS. Собственно dfs. Компоненты связности.

```cpp
void dfs(int v):
    if (used[v]) return;
    used[v] = true;
    for (auto x : g[v]):
        dfs(x);
```
* Его величество ДЭЭФЭС.
* Для поиска компонент связности:
```cpp
for (int a = 0; a < n; ++a) {
    if !used[a]
        cc++, dfs(a);
}
```

### <span style="color:green">(a)</span> 104. DFS. Восстановление пути в dfs. Обратный ход рекурсии.

```cpp
bool dfs(int v) {
    if (v == goal) { // пытаемся прийти к цели
        path.push_back(v); // пометили что пришли
        return 1; // и закончили
    }
    for (int x : g[v])
        if (dfs(x)) { // если там успешно дошли
            path.push_back(x); // пихаем в путь
            return 1; // и закончили
        }
    return 0; // типа никуда не дошли
}
```

### <span style="color:green">(a)</span> 105. DFS. DAG. Topsort. Определение и нахождение.

* `Топологическая сортировка графа` - сопоставление вершинам номеров таких что $ind[v]: \forall e(a\rightarrow b) \: ind[a] < ind[b]$.
* Рекурсивный он вот он:
```cpp
bool dfs(int v) {
    in_time_order.push_back(v);
    // ... - наши тёмные дфс-ные делишки
    out_time_order.push_back(v);
}
```
* В `аут_тайм_ордере` в перевёрнутом порядке теперь лежит искомый топсорт.

### <span style="color:green">(a)</span> 106. DFS. Поиск цикла в орграфе.

* Зашли - покрасили, видим что идём по крашеному - значит цикл.
```cpp
bool dfs(int v) {
    color[v] = 1; // "серая" вершина
    // ...
    color[v] = 2; // "чёрная" вершина.
}
```
* Пришли в серую/чёрную в неорграфе - цикл
* Пришли в серую в орграфе - цикл.

### <span style="color:green">(a)</span> 107. DFS. Остовное дерево dfs. Как найти?

* Остовное дерево `dfs` - идём `dfs`-ом, никуда не заходя дважды, и посещая при этом все-все-все вершинки. Запоминаем, по каким рёбрам идём. Нашли некоторое остовное дерево графа.

### <span style="color:blue">(b)</span> 108. DFS. Классифицакия рёбер относительно остовного дерева.

* **Древесные:** принадлежат остовному дереву графа.
* **Прямые:** идут вниз по дереву.
* **Обратные:** идут вверх по дереву.
* **Перекрёстные:** идут между разными поддеревьями.

### <span style="color:red">(c)</span> 109. DFS. Отсутствие перекрёстных рёбер для неор графа.

### <span style="color:green">(a)</span> 110. DFS. Сильная связность. Def. Простой алгоритм выделения к.с.с. вершины $v$ за $\mathcal{O}(V + E)$.

* Компонента сильной связности - множество вершин, где из любого можно прийти в любое другое.

### <span style="color:blue">(b)</span> 111. DFS. Поиск всех к.с.с. за $\mathcal{O}(V + E)$. Только алгоритм.

* Запустим топсорт. Перебираем вершины в полученном порядке. Если вершина не покрашена, красим достижимые из неё по обратным рёбрам (ну тип было $a\rightarrow b$ стало $b \rightarrow a$). получим ровно компоненту связности `v`.

### <span style="color:red">(c)</span>  111. DFS. Поиск всех к.с.с. за $\mathcal{O}(V + E)$. Обоснование корректности.

### <span style="color:blue">(b)</span> 113. DFS. Поиск конденсации за $\mathcal{O}(V + E)$.

* За $\mathcal{O}(V + E)$ мы нашли к.с.с. для каждой вершины, значит нашли все к.с.с, их очень нетрудно сконденсировать.

### <span style="color:red">(c)</span> DFS. Поиск транзитивного замыкания за $\mathcal{O}(V E/w)$.